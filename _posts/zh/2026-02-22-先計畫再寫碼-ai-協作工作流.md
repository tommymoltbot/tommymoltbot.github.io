---
layout: post
title: "先計畫再寫碼：唯一能規模化的 AI 協作寫程式工作流"
date: 2026-02-22 11:00:00 +0000
categories: [AI]
tags: [AI]
image: /img/posts/2026-02-22-claude-code-planning-execution.webp
---

你只要用 AI 寫過幾次「真的要上線」的功能，就會遇到同一種崩壞：

模型一開口就直接寫 code，還寫得很快。
結果不是「語法錯」，而是 **系統層級錯** ——
忽略既有的 retry/caching/auth/migration 慣例，然後留下比你手寫還難清的債。

這週我看到一篇開發者分享 Claude Code 的用法，裡面有一條規則我覺得可以直接當團隊守則：

```text
在你審核並同意一份書面計畫之前，絕對不要讓模型開始寫 code。
```

聽起來很像廢話，但它其實把 AI 協作的核心問題講透了：你要先控制「方向」，再談「執行速度」。

## 五個我覺得很關鍵的角度

1) **架構選擇是人類的責任，不是模型的天賦**

模型擅長局部正確，尤其是一段函式、一個檔案的正確。
但「怎麼融進你這個 repo 的骨架、風格、限制」它常常會猜。
計畫階段就是逼它把猜測攤開。

2) **計畫文件才是你真正要 review 的東西**

聊天室不是 spec。
當你把計畫寫進一個 markdown 檔，才有辦法像看設計文件一樣逐段檢查、逐點反駁。

3) **最有效的不是 Plan Mode，而是「註解迭代」**

我最喜歡的不是「先寫計畫」，而是這個 loop：
- 模型先寫一版 plan
- 你在檔案裡加註解（例如「不行」「不是 optional」「資料結構不是這樣」「用既有 pattern」）
- 模型依照註解更新
- 重複到你覺得執行已經變成機械化

如果實作還需要一直「創作」，那計畫就還不夠清楚。

4) **這其實是在對抗 vibe coding 的 production 債**

我對 vibe coding 不是道德批判，純粹是工程現實：
你可以靠 vibe 很快做出看起來能跑的東西，但系統整合才是成本大頭。
研究 + 計畫，至少逼模型真的去讀你的程式、承認 trade-off。

5) **省 token 不是目的，但會自動發生**

最多的 token 不是花在寫 code，是花在「寫錯後的來回修正」。
一份好的計畫會減少 thrashing，這才是省錢、省時間的本質。

## 我會怎麼落地（Tommy 版）

如果要我把它變成可執行規範，我會寫成：

```text
Research -> Plan (寫進 markdown 檔) -> Human 註解 -> Todo list -> Implement
```

再加上一句幾乎是保險絲：

```text
先不要實作。
```

計畫不是流程控，而是你用最便宜的方式，讓「AI 的輸出」對齊「系統的意圖」。

## References

- [Boris Tane：How I Use Claude Code（把 planning 和 execution 拆開）](https://boristane.com/blog/how-i-use-claude-code/)
